#include "StdInc.h"
#include "VehicleColor.h"

using namespace SharedUtil;

VehicleColor::VehicleColor()
{
	// Init
	this->m_ucPaletteColors[ 0 ] = 0; // Palette color 0 is black
	this->m_ucPaletteColors[ 1 ] = 0;
	this->m_ucPaletteColors[ 2 ] = 0;
	this->m_ucPaletteColors[ 3 ] = 0;

	this->m_RGBColors[ 0 ] = 0;
	this->m_RGBColors[ 1 ] = 0;
	this->m_RGBColors[ 2 ] = 0;
	this->m_RGBColors[ 3 ] = 0;

	this->m_bPaletteColorsWrong = false;
	this->m_bRGBColorsWrong = false;
}

// Use black for colours that are not used (bandwidth saving)
void VehicleColor::SetRGBColors( Color color1, Color color2, Color color3, Color color4 )
{
	if( this->m_RGBColors[ 0 ] != color1 || this->m_RGBColors[ 1 ] != color2 || this->m_RGBColors[ 2 ] != color3 || this->m_RGBColors[ 3 ] != color4 )
	{
		this->m_RGBColors[ 0 ] = color1;
		this->m_RGBColors[ 1 ] = color2;
		this->m_RGBColors[ 2 ] = color3;
		this->m_RGBColors[ 3 ] = color4;

		this->InvalidatePaletteColors();
	}
}

void VehicleColor::SetPaletteColors( uchar ucColor1, uchar ucColor2, uchar ucColor3, uchar ucColor4 )
{
	if( this->m_ucPaletteColors[ 0 ] != ucColor1 || this->m_ucPaletteColors[ 1 ] != ucColor2 || this->m_ucPaletteColors[ 2 ] != ucColor3 || this->m_ucPaletteColors[ 3 ] != ucColor4 )
	{
		this->m_ucPaletteColors[ 0 ] = ucColor1;
		this->m_ucPaletteColors[ 1 ] = ucColor2;
		this->m_ucPaletteColors[ 2 ] = ucColor3;
		this->m_ucPaletteColors[ 3 ] = ucColor4;

		this->InvalidateRGBColors();
	}
}

void VehicleColor::SetRGBColor( uint uiSlot, Color color )
{
	this->ValidateRGBColors();

	uiSlot = Min( uiSlot, static_cast< uint >( NUMELMS( this->m_RGBColors ) ) );

	if( this->m_RGBColors[ uiSlot ] != color )
	{
		this->m_RGBColors[ uiSlot ] = color;

		this->InvalidatePaletteColors();
	}
}

void VehicleColor::SetPaletteColor( uint uiSlot, uchar ucColor )
{
	this->ValidatePaletteColors();

	uiSlot = Min( uiSlot, static_cast< uint >( NUMELMS( this->m_ucPaletteColors ) ) );

	if( this->m_ucPaletteColors[ uiSlot ] != ucColor )
	{
		this->m_ucPaletteColors[ uiSlot ] = ucColor;

		this->InvalidateRGBColors();
	}
}

// Get a slot colour as a palette index
uchar VehicleColor::GetPaletteColor( uint uiSlot ) const
{
	this->ValidatePaletteColors();

	uiSlot = Min( uiSlot, static_cast< uint >( NUMELMS( this->m_ucPaletteColors ) ) );

	return this->m_ucPaletteColors[ uiSlot ];
}

// Get a slot colour as an RGB colour
Color VehicleColor::GetRGBColor( uint uiSlot ) const
{
	this->ValidateRGBColors();

	uiSlot = Min( uiSlot, static_cast< uint >( NUMELMS( this->m_RGBColors ) ) );

	return this->m_RGBColors[ uiSlot ];
}

//  Can return: 1,2,3, or 4
int VehicleColor::GetNumColorsUsed( void ) const
{
	// Find last unblack
	int i;

	for( i = NUMELMS( this->m_RGBColors ); i > 1; i-- )
	{
		if( this->GetRGBColor( i - 1 ) )
		{
			break;
		}
	}

	ASSERT( i >= 1 && i <= 4 );

	return i;
}


// Switching to RGB mode
void VehicleColor::InvalidatePaletteColors() const
{
	this->m_bRGBColorsWrong = false;
	this->m_bPaletteColorsWrong = true;
}

// Switching to palette mode
void VehicleColor::InvalidateRGBColors() const
{
	this->m_bPaletteColorsWrong = false;
	this->m_bRGBColorsWrong = true;
}

// Ensure switched
void VehicleColor::ValidateRGBColors() const
{
	if( this->m_bRGBColorsWrong )
	{
		this->m_bRGBColorsWrong = false;

		for( uint i = 0; i < NUMELMS( this->m_RGBColors ); i++ )
		{
			this->m_RGBColors[ i ] = GetRGBFromPaletteIndex( this->m_ucPaletteColors[ i ] );
		}
	}
}

// Ensure switched
void VehicleColor::ValidatePaletteColors() const
{
	if( this->m_bPaletteColorsWrong )
	{
		this->m_bPaletteColorsWrong = false;

		for( uint i = 0; i < NUMELMS( this->m_ucPaletteColors ); i++ )
		{
			this->m_ucPaletteColors[ i ] = GetPaletteIndexFromRGB( this->m_RGBColors[ i ] );
		}
	}
}

static const uchar paletteColorTable8[] =
{
	0x00, 0x00, 0x00, 0xff, 0xf5, 0xf5, 0xf5, 0xff, 0x2a, 0x77, 0xa1, 0xff, 0x84, 0x04, 0x10, 0xff,
	0x26, 0x37, 0x39, 0xff, 0x86, 0x44, 0x6e, 0xff, 0xd7, 0x8e, 0x10, 0xff, 0x4c, 0x75, 0xb7, 0xff,
	0xbd, 0xbe, 0xc6, 0xff, 0x5e, 0x70, 0x72, 0xff, 0x46, 0x59, 0x7a, 0xff, 0x65, 0x6a, 0x79, 0xff,
	0x5d, 0x7e, 0x8d, 0xff, 0x58, 0x59, 0x5a, 0xff, 0xd6, 0xda, 0xd6, 0xff, 0x9c, 0xa1, 0xa3, 0xff,
	0x33, 0x5f, 0x3f, 0xff, 0x73, 0x0e, 0x1a, 0xff, 0x7b, 0x0a, 0x2a, 0xff, 0x9f, 0x9d, 0x94, 0xff,
	0x3b, 0x4e, 0x78, 0xff, 0x73, 0x2e, 0x3e, 0xff, 0x69, 0x1e, 0x3b, 0xff, 0x96, 0x91, 0x8c, 0xff,
	0x51, 0x54, 0x59, 0xff, 0x3f, 0x3e, 0x45, 0xff, 0xa5, 0xa9, 0xa7, 0xff, 0x63, 0x5c, 0x5a, 0xff,
	0x3d, 0x4a, 0x68, 0xff, 0x97, 0x95, 0x92, 0xff, 0x42, 0x1f, 0x21, 0xff, 0x5f, 0x27, 0x2b, 0xff,
	0x84, 0x94, 0xab, 0xff, 0x76, 0x7b, 0x7c, 0xff, 0x64, 0x64, 0x64, 0xff, 0x5a, 0x57, 0x52, 0xff,
	0x25, 0x25, 0x27, 0xff, 0x2d, 0x3a, 0x35, 0xff, 0x93, 0xa3, 0x96, 0xff, 0x6d, 0x7a, 0x88, 0xff,
	0x22, 0x19, 0x18, 0xff, 0x6f, 0x67, 0x5f, 0xff, 0x7c, 0x1c, 0x2a, 0xff, 0x5f, 0x0a, 0x15, 0xff,
	0x19, 0x38, 0x26, 0xff, 0x5d, 0x1b, 0x20, 0xff, 0x9d, 0x98, 0x72, 0xff, 0x7a, 0x75, 0x60, 0xff,
	0x98, 0x95, 0x86, 0xff, 0xad, 0xb0, 0xb0, 0xff, 0x84, 0x89, 0x88, 0xff, 0x30, 0x4f, 0x45, 0xff,
	0x4d, 0x62, 0x68, 0xff, 0x16, 0x22, 0x48, 0xff, 0x27, 0x2f, 0x4b, 0xff, 0x7d, 0x62, 0x56, 0xff,
	0x9e, 0xa4, 0xab, 0xff, 0x9c, 0x8d, 0x71, 0xff, 0x6d, 0x18, 0x22, 0xff, 0x4e, 0x68, 0x81, 0xff,
	0x9c, 0x9c, 0x98, 0xff, 0x91, 0x73, 0x47, 0xff, 0x66, 0x1c, 0x26, 0xff, 0x94, 0x9d, 0x9f, 0xff,
	0xa4, 0xa7, 0xa5, 0xff, 0x8e, 0x8c, 0x46, 0xff, 0x34, 0x1a, 0x1e, 0xff, 0x6a, 0x7a, 0x8c, 0xff,
	0xaa, 0xad, 0x8e, 0xff, 0xab, 0x98, 0x8f, 0xff, 0x85, 0x1f, 0x2e, 0xff, 0x6f, 0x82, 0x97, 0xff,
	0x58, 0x58, 0x53, 0xff, 0x9a, 0xa7, 0x90, 0xff, 0x60, 0x1a, 0x23, 0xff, 0x20, 0x20, 0x2c, 0xff,
	0xa4, 0xa0, 0x96, 0xff, 0xaa, 0x9d, 0x84, 0xff, 0x78, 0x22, 0x2b, 0xff, 0x0e, 0x31, 0x6d, 0xff,
	0x72, 0x2a, 0x3f, 0xff, 0x7b, 0x71, 0x5e, 0xff, 0x74, 0x1d, 0x28, 0xff, 0x1e, 0x2e, 0x32, 0xff,
	0x4d, 0x32, 0x2f, 0xff, 0x7c, 0x1b, 0x44, 0xff, 0x2e, 0x5b, 0x20, 0xff, 0x39, 0x5a, 0x83, 0xff,
	0x6d, 0x28, 0x37, 0xff, 0xa7, 0xa2, 0x8f, 0xff, 0xaf, 0xb1, 0xb1, 0xff, 0x36, 0x41, 0x55, 0xff,
	0x6d, 0x6c, 0x6e, 0xff, 0x0f, 0x6a, 0x89, 0xff, 0x20, 0x4b, 0x6b, 0xff, 0x2b, 0x3e, 0x57, 0xff,
	0x9b, 0x9f, 0x9d, 0xff, 0x6c, 0x84, 0x95, 0xff, 0x4d, 0x84, 0x95, 0xff, 0xae, 0x9b, 0x7f, 0xff,
	0x40, 0x6c, 0x8f, 0xff, 0x1f, 0x25, 0x3b, 0xff, 0xab, 0x92, 0x76, 0xff, 0x13, 0x45, 0x73, 0xff,
	0x96, 0x81, 0x6c, 0xff, 0x64, 0x68, 0x6a, 0xff, 0x10, 0x50, 0x82, 0xff, 0xa1, 0x99, 0x83, 0xff,
	0x38, 0x56, 0x94, 0xff, 0x52, 0x56, 0x61, 0xff, 0x7f, 0x69, 0x56, 0xff, 0x8c, 0x92, 0x9a, 0xff,
	0x59, 0x6e, 0x87, 0xff, 0x47, 0x35, 0x32, 0xff, 0x44, 0x62, 0x4f, 0xff, 0x73, 0x0a, 0x27, 0xff,
	0x22, 0x34, 0x57, 0xff, 0x64, 0x0d, 0x1b, 0xff, 0xa3, 0xad, 0xc6, 0xff, 0x69, 0x58, 0x53, 0xff,
	0x9b, 0x8b, 0x80, 0xff, 0x62, 0x0b, 0x1c, 0xff, 0x5b, 0x5d, 0x5e, 0xff, 0x62, 0x44, 0x28, 0xff,
	0x73, 0x18, 0x27, 0xff, 0x1b, 0x37, 0x6d, 0xff, 0xec, 0x6a, 0xae, 0xff,
};


uchar VehicleColor::GetPaletteIndexFromRGB( Color color )
{
	ulong ulBestDist = 0xFFFFFFFF;
	uchar ucBestMatch = 0;

	for( uint i = 0; i < NUMELMS( paletteColorTable8 ) / 4; i++ )
	{
		int r = paletteColorTable8[ i * 4 + 0 ] - color.R;
		int g = paletteColorTable8[ i * 4 + 1 ] - color.G;
		int b = paletteColorTable8[ i * 4 + 2 ] - color.B;

		ulong ulDist = r * r + g * g + b * b;

		if( ulDist < ulBestDist )
		{
			ulBestDist = ulDist;
			ucBestMatch = i;
		}
	}

	return ucBestMatch;
}

Color VehicleColor::GetRGBFromPaletteIndex( uchar ucColor )
{
	ucColor = Min< uchar >( ucColor, static_cast< uint >( NUMELMS( paletteColorTable8 ) / 4 ) );

	uchar r = paletteColorTable8[ ucColor * 4 ];
	uchar g = paletteColorTable8[ ucColor * 4 + 1 ];
	uchar b = paletteColorTable8[ ucColor * 4 + 2 ];

	return ColorRGBA( r, g, b, 0 );
}
